[{"name":"Simplify","comment":" Reports when an expression can be simplified.\n\n    config =\n        [ Simplify.rule Simplify.defaults\n        ]\n\n@docs rule\n@docs Configuration, defaults, ignoreCaseOfWithConstructors\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template jfmengels/elm-review-simplify/example --rules Simplify\n```\n\n\n## Simplifications\n\nBelow is the list of all kinds of simplifications this rule applies.\n\n\n### Booleans\n\n    x || True\n    --> True\n\n    x || False\n    --> x\n\n    x && True\n    --> x\n\n    x && False\n    --> False\n\n    not True\n    --> False\n\n    x == True\n    --> x\n\n    x /= False\n    --> x\n\n    not x == not y\n    --> x == y\n\n    anything == anything\n    --> True\n\n    anything /= anything\n    --> False\n\n    not >> not\n    --> identity\n\n\n### If expressions\n\n    if True then x else y\n    --> x\n\n    if False then x else y\n    --> y\n\n    if condition then x else x\n    --> x\n\n    if condition then True else False\n    --> condition\n\n    if condition then False else True\n    --> not condition\n\n\n### Case expressions\n\n    case condition of\n        True -> x\n        False -> y\n    --> if condition then x else y\n\n    case condition of\n        False -> y\n        True -> x\n    --> if not condition then x else y\n\n    case value of\n        A _ -> x\n        B -> x\n    --> x\n\n\n### Basics functions\n\n    identity x\n    --> x\n\n    f >> identity\n    --> f\n\n    always x y\n    --> x\n\n    f >> always x\n    --> always x\n\n\n### Lambdas\n\n    (\\\\() -> x) data\n    --> x\n\n    (\\\\() y -> x) data\n    --> (\\y -> x)\n\n    (\\\\_ y -> x) data\n    --> (\\y -> x)\n\n\n### Operators\n\n    (++) a b\n    --> a ++ b\n\n\n### Numbers\n\n    n + 0\n    --> n\n\n    n - 0\n    --> n\n\n    0 - n\n    --> -n\n\n    n * 1\n    --> n\n\n    n * 0\n    --> 0\n\n    n / 1\n    --> n\n\n    -(-n)\n    --> n\n\n    negate >> negate\n    --> identity\n\n\n### Strings\n\n    \"a\" ++ \"\"\n    --> \"a\"\n\n    String.isEmpty \"\"\n    --> True\n\n    String.isEmpty \"a\"\n    --> False\n\n    String.concat []\n    --> \"\"\n\n    String.join str []\n    --> \"\"\n\n    String.join \"\" list\n    --> String.concat list\n\n    String.length \"abc\"\n    --> 3\n\n    String.repeat n \"\"\n    --> \"\"\n\n    String.repeat 0 str\n    --> \"\"\n\n    String.repeat 1 str\n    --> str\n\n    String.words \"\"\n    --> []\n\n    String.lines \"\"\n    --> []\n\n\n### Maybe\n\n    Maybe.map identity x\n    --> x\n\n    Maybe.map f Nothing\n    --> Nothing\n\n    Maybe.map f (Just x)\n    --> Just (f x)\n\n    MaybeThen f Nothing\n    --> Nothing\n\n    Maybe.andThen (always Nothing) x\n    --> Nothing\n\n    Maybe.andThen (\\a -> Just b) x\n    --> Maybe.map (\\a -> b) x\n\n    Maybe.andThen f (Just x)\n    --> f x\n\n    Maybe.withDefault x Nothing\n    --> x\n\n    Maybe.withDefault x (Just y)\n    --> y\n\n\n### Result\n\n    Result.map identity x\n    --> x.and\n\n    Result.map f (Err x)\n    --> Err x\n\n    Result.map f (Ok x)\n    --> Ok (f x)\n\n    Result.andThen f (Err x)\n    --> Err x\n\n    Result.andThen f (Ok x)\n    --> f x\n\n    Result.andThen (\\a -> Ok b) x\n    --> Result.map (\\a -> b) x\n\n    Result.withDefault x (Err y)\n    --> x\n\n    Result.withDefault x (Ok y)\n    --> y\n\n\n### Lists\n\n    a :: []\n    --> [ a ]\n\n    a :: [ b ]\n    --> [ a, b ]\n\n    [ a ] ++ list\n    --> a :: list\n\n    [] ++ list\n    --> list\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    [ a, b ] ++ [ c ]\n    --> [ a, b, c ]\n\n    List.concat []\n    --> []\n\n    List.concat [ [ a, b ], [ c ] ]\n    --> [ a, b, c ]\n\n    List.concat [ a, [ 1 ], [ 2 ] ]\n    --> List.concat [ a, [ 1, 2 ] ]\n\n    List.concatMap identity x\n    --> List.concat list\n\n    List.concatMap identity\n    --> List.concat\n\n    List.concatMap (\\a -> a) list\n    --> List.concat list\n\n    List.concatMap fn [ x ]\n    --> fn x\n\n    List.concatMap (always []) list\n    --> []\n\n    List.map fn [] -- same for List.filter, List.filterMap, ...\n    --> []\n\n    List.map identity list\n    --> list\n\n    List.map identity\n    --> identity\n\n    List.filter (always True) list\n    --> list\n\n    List.filter (\\a -> True) list\n    --> list\n\n    List.filter (always False) list\n    --> []\n\n    List.filter (always True)\n    --> identity\n\n    List.filter (always False)\n    --> always []\n\n    List.filterMap Just list\n    --> list\n\n    List.filterMap (\\a -> Just a) list\n    --> list\n\n    List.filterMap Just\n    --> identity\n\n    List.filterMap (always Nothing) list\n    --> []\n\n    List.filterMap (always Nothing)\n    --> (always [])\n\n    List.isEmpty []\n    --> True\n\n    List.isEmpty [ a ]\n    --> False\n\n    List.isEmpty (x :: xs)\n    --> False\n\n    List.all fn []\n    --> True\n\n    List.all (always True) list\n    --> True\n\n    List.any fn []\n    --> True\n\n    List.any (always False) list\n    --> True\n\n    List.range 6 3\n    --> []\n\n    List.length [ a ]\n    --> 1\n\n    List.repeat n []\n    --> []\n\n    List.repeat 0 list\n    --> []\n\n    List.partition fn []\n    --> ( [], [] )\n\n    List.partition (always True) list\n    --> ( list, [] )\n\n\n### Set\n\n    Set.map fn Set.empty -- same for Set.filter, Set.remove...\n    --> Set.empty\n\n    Set.map identity list\n    --> list\n\n    Set.map identity\n    --> identity\n\n    Set.isEmpty Set.empty\n    --> True\n\n    Set.member x Set.empty\n    --> False\n\n    Set.fromList []\n    --> Set.empty\n\n    Set.toList Set.empty\n    --> []\n\n    Set.length Set.empty\n    --> 0\n\n    Set.intersect Set.empty set\n    --> Set.empty\n\n    Set.diff Set.empty set\n    --> Set.empty\n\n    Set.diff set Set.empty\n    --> set\n\n    Set.union set Set.empty\n    --> set\n\n    Set.insert x Set.empty\n    --> Set.singleton x\n\n    Set.partition fn Set.empty\n    --> ( Set.empty, Set.empty )\n\n    Set.partition (always True) set\n    --> ( list, Set.empty )\n\n\n### Dict\n\n    Dict.isEmpty Dict.empty\n    --> True\n\n    Dict.fromList []\n    --> Dict.empty\n\n    Dict.toList Dict.empty\n    --> []\n\n    Dict.size Dict.empty\n    --> 0\n\n\n### Cmd / Sub\n\nAll of these also apply for `Sub`.\n\n    Cmd.batch []\n    --> Cmd.none\n\n    Cmd.batch [ a ]\n    --> a\n\n    Cmd.batch [ a, Cmd.none, b ]\n    --> Cmd.batch [ a, b ]\n\n    Cmd.map identity cmd\n    --> cmd\n\n    Cmd.map fn Cmd.none\n    --> Cmd.none\n\n","unions":[{"name":"Configuration","comment":" Configuration for this rule. Create a new one with [`defaults`](#defaults) and use [`ignoreCaseOfWithConstructors`](#ignoreCaseOfWithConstructors) to alter it.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"defaults","comment":" Default configuration for this rule. Use [`ignoreCaseOfWithConstructors`](#ignoreCaseOfWithConstructors) if you want to change the configuration.\n\n    config =\n        [ Simplify.defaults\n            |> Simplify.ignoreCaseOfWithConstructors [ \"Module.Name.Type\" ]\n            |> Simplify.rule\n        ]\n\n","type":"Simplify.Configuration"},{"name":"ignoreCaseOfWithConstructors","comment":" Ignore some reports about types used in case expressions.\n\nThis rule simplifies the following construct:\n\n    module Module.Name exposing (..)\n\n    type Type = A | B\n\n    case value of\n        A -> x\n        B -> x\n    --> x\n\nIn some cases, you may want to disable this simplification because you expect to change or add constructors to this custom type.\nKeeping the case expression as it is will make the compiler remind you to update this code, which can be valuable.\n\nUsing the following configuration, case of expressions — where all variants of the `Type` custom type\nfrom the `Module.Name` module appear — will not be simplified.\n\n    config =\n        [ Simplify.defaults\n            |> Simplify.ignoreCaseOfWithConstructors [ \"Module.Name.Type\" ]\n            |> Simplify.rule\n        ]\n\nNote that if you use a wildcard, you will still get the simplification, since in this case the compiler will\nnot remind you anyway.\n\n    case value of\n        A -> x\n        _ -> x\n    --> x\n\nI personally don't recommend to use this function too much, because this could be a sign of premature abstraction, and because\nI think that often [You Aren't Gonna Need this code](https://jfmengels.net/safe-dead-code-removal/#yagni-you-arent-gonna-need-it).\n\nOnly use it for custom types that you think will change soon. When using it, I recommend not keeping it there too long\nand to come back after a while to see if this exception is still worth having. Maybe add a comment with the date and an\nexplanation next to each exception?\n\n","type":"List.List String.String -> Simplify.Configuration -> Simplify.Configuration"},{"name":"rule","comment":" Rule to simplify Elm code.\n","type":"Simplify.Configuration -> Review.Rule.Rule"}],"binops":[]}]